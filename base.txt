1.ARP(地址解析协议):是根据IP地址获取物理地址的一个TCP/IP协议。


2.http -> DNS（真实地址查询） -> 协议栈（指南帮手）-> TCP （传输）-> IP （远程定位）-> MAC （两点传输）-> 网关（出口） -> 交换机（送别者） -> 路由器 （出境大门）

3.TCP/IP模型: 应用层-》传输层=》网络层=》网络接口层

4.Http(HyperText Transfer Protocol):超文本 传输 协议

5.http常见的状态码：
	1xx:提示信息，表示目前是协议处理的中间状态，还需要后续的操作 
	2xx:成功，报文已经收到，并被正确处理；  200、204、206
	3xx:重定向，资源位置发生变动，需要客户端重新发送请求 301、302、304
	4xx:客户端错误，请求报文有误，服务器无法处理 403、400、404
	5xx:服务器错误，服务器在处理请求时内部发生了错误 500、501、502、503

6.http常见的字段：
	Host字段：客户端发送请求时，用来指定服务器的域名
	content-length:服务器返回数据时，表明本次回应的数据长度
	connection字段：最常见用于客户端要求服务器使用【HTTP长连接】机制，一遍其他请求复用
	Content-Type字段：服务器回应告诉客户端本次数据格式
	Content-Encoding:说明数据的压缩方法，表示服务器返回的数据使用了的压缩格式

7.CET和POST区别
     GET 的语义是请求指定的资源，GEt方法是安全且幂等、可被缓存的
     POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全、不幂等、不可缓存

8.HTTP缓存技术
    强制缓存：指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
    	HTTP响应头部字段：
		Cache-Control:是一个相对时间；（优先级高于Expires）
		Expires:绝对时间

    协商缓存：是与服务端协商之后，通过协商结果来判断是否使用本地缓存。
	协商缓存可以基于两种头部来实现：
		1）请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现
		2）请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段

9.HTTP特性
   HTTP协议是基于TCP/IP,并且使用了 【请求-应答】 的通信模式，所以性能的关键就在这两点
   1）HTTP1.1的优点 ：
	最突出的优点：简单、灵活和易于拓展、应用广泛和跨平台
   2）HTTP1.1缺点：
	优缺点一体的双刃剑：无状态、明文传输，同时还有一大缺点不安全
	无状态的好处：因为服务器不会记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务；
	无状态的坏处：既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦（eg:需要知道用户的身份信息时，购物等等）对于无状态的解决方案，比较简单的方式用Cookie技术。  Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态
	明文传输的好处：在传输过程中是可方便阅读的，为调试工作带来极大的便利；但正是这样，HTTP的信息都暴露在光天化日之下，相当于信息裸奔，在传输过程中很容易被窃取

    HTTP1.1 建立了长连接/持久连接，有效减少了TCP链接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
    HTTP1.1采用了长连接的方式，使得管道网络传输成为可能。但管道只解决了请求的队头阻塞，没有解决响应的队头阻塞，且该功能一直没有被使用

10.HTTP与HTTPS
     HTTPS 在 HTTP 与TCP层之间加入了 SSL/TLS 协议，解决被窃听、篡改、冒充的风险
     信息加密+校验机制+身份证书
     具体过程：略

11.HTTPS是如何建立连接的？其间交互了什么？
     SSL/TLS 协议基本流程：
	1）客户端向服务器索要并验证服务器的公钥
	2）双方协商生产会话密钥
	3）双方采用会话密钥进行加密通信
     前两步也就是SSL/TLS的建立过程，也就是TLS握手阶段

     TLS协议建立的详细过程：
	1.Client Hello
	   首先，由客户端向服务器发起加密通信请求，在这一步客户端主要向服务器发胜以下信息：
		1）客户端支持的TLS协议版本
		2）客户端生产的随机数（Client Random）,是后面用于生产【会话密钥】的条件之一。
		3）客户端支持的密码套件列表，如RSA加密算法
	2.SeverHello
	   服务器收到客户端请求后，向客户端发出响应。服务器回应的内容有如下内容：
		1)确认TLS协议版本，如果浏览器不支持，则关闭加密通信
		2）服务器生产的随机数（SevereRandom）,也是后面用于生产【会话密钥】的条件之一。
		3）确认的密码套件列表，如RSA加密算法
		4）服务器的数字证书
	3.客户端回应
	    客户端收到服务器的回应值后，首先通过浏览器或者操作系统中的CA公钥，确认服务器的数字证数的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
		1）一个随机数（pre-master key）。该随机数会被服务器公钥加密
		2）加密通信算法改变通知，表示随后的信息都将用【会话密钥】加密通信
		3）客户端握手结束通知。表示客户端的握手阶段结束，这一项同事把之前所有内容发胜的数据做个摘要，用来供服务端校验
	   上面第一项的随机数是整个握手阶段的第三个随机数，会发送给服务端，所以这个随机数客户端和服务端都是一样的

	   服务器和客户端有了这三个随机数，接着就用双方协商的加密算法，各自生成本次通信的【会话密钥】

	4.服务器的最后回应
	   服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的【会话密钥】，然后向客户端发送最后的信息：
		1）加密通信算法改变通知，表示随后的信息都将用【会话密钥】加密通信
		2）服务器端握手结束通知，表示服务器的握手阶段就已经结束。这一项同事把之前所有内容的发胜数据做个摘要，用来供客户端校验

	   至此，整个TLS的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用【会话密钥】加密内容

12.客户端校验数字证书:略

13.HTTPS的应用数据是如何保证完整性的？
    TLS在实现上分为握手协议和记录协议两层：
	TLS握手协议就是前面所说的TLS四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据(即HTTP数据)；
	TLS记录协议负责保护应用程序数据并验证其完整性和来源，所以对HTTP数据加密是使用记录协议。
	
	TSL记录协议[主要负责保护消息的压缩，加密及数据的认证]，过程如下：
		1）消息被分割成多个较短的片段，然后分别对每个片段进行压缩。
		2）经过压缩的片段会被加上消息认证码（MAC值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证。通过附加消息认证码的MAC值，可以识别胡篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
		3）经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
		4）经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据
	记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

14.「HTTPS 是先进行 TCP 三次握手，再进行 TLSv1.2 四次握手」
   「HTTPS 中的 TLS 握手过程可以同时进行三次握手」，其前提如下：
	1）客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；2）客户端和服务端已经完成过一次通信；

	所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。

15.HTTPS ECDHE握手解析 【目前广泛运用的】：详情略

16.HTTPS RSA握手协议解析：详情略

17.HTTPS如何优化？
	硬件优化（选择可以支持 AES-NI 特性的CPU）、软件优化、协议优化(密钥交换算法优化[ECDHE算法>RSA算法、TLS算法升级等等])、证书优化、会话复用

18.会话复用：TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，就减少 TLS 握手的性能损耗了。会话复用包含两种方式：Session ID、Session Ticket

	1)Session ID 的工作原理是:客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。 
	session ID 有两不足：服务器必须保持每一个客户端的会话密钥，随着客户端的增多，服务器的内存压力也会越大；服务器必须保持每一个客户端的会话密钥，随着客户端的增多，服务器的内存压力也会越大。

	2)Session Ticket:客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket,客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。

	   
19.HTTP1.1 如何优化？

	第一个思路是：通过缓存技术来避免发送HTTP请求。
		客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端	发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。

	第二个思路是：减少HTTP请求的次数。
		
		将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；
		将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；
		按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数
	
20.HTTP2 优点？
	1）兼容HTTP1.1
	2)头部压缩：对于常见的 HTTP 头部通过静态表和 Huffman 编码的方式，将体积压缩了近一半，而将后续请求的头部建立动态表，将体积压缩近90%，大大提高了编码效率，同时节约了带宽资源
	3）二进制帧：将文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析
	4）并发传输：HTTP/2 实现了 Stream 并发，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧1-> B 请求帧1-> A 请求帧2 -> B 请求帧2，但是同一个 Stream 里的帧必须严格有序。
	5）服务器主动推送资源：服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。

21. HTTP2 缺点：
	1）队头阻塞：HTTP2是基于TCP协议来传输数据的，TCP是字节流协议，TCP层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用，那么当【前一个字节数据】没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等这1个字节数据到达时，HTTP2应用层才能从内核中拿到数据，这就是HTTP2队头阻塞的问题
	2）TCP与TLS的握手延迟：TCP三次握手、TLS四次握手的时延
	3）网络迁移需要重新连接：一个TCP连接是由四元组（源IP地址，源端口，目标IP地址，目标端口）确定的，这意味着如果IP地址或者端口变动了，就会导致需要TCP与TLS重新握手，这不利于移动设备切换网络的场景。


22.HTTP3 还未正式推出，但基本特性已确定 ，其中用到QUIC协议【可以】，TCP协议用UDP协议【无序、无需连接】替换，省去连接的时间，详情：略

23.TCP三个特点：面向连接、可靠、基于字节流

24.既然有HTTP协议，为什么还要有RPC？
   =》70年代TCP， 裸用TCP会有问题=》80年代RPC=》既然有RPC为什么要有HTTP协议？
	HTTP主要用于b/s架构，而RPC更多用于c/s架构。但其实现在已经没有分那么清了，b/s c/s在慢慢融合。很多软件同时支持多端，比如百度云盘。如果通信协议都使用HTTP的话，那服务器只用一套就够，而RPC就开始退居幕后，一般用于公司内部集群里，哥哥微服务之间的通讯。
   =》都用HTTP得了，为什么还要用RPC?
	从服务发现、底层连接、传输的内容来看，二者区别最大的是传输内容，
	HTTP的传输有消息头和消息体（body）,http的消息头内容非常多的冗余，且body的json结构里也是如此
	RPC定制化程度更高，采用体积更下的protobuf或其他序列化协议去保存结构体数据，同时不用像HTTP那样考虑各种浏览器行为，如302重定向跳转，因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP【特指版本1.1】，选择RPC的主要原因
	
  	 HTTP2.0在HTTP1.1的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。

25.有HTTP协议为什么还要有webSocket?

	TCP连接的两端，在统一时间里，双方都可以主动向对方发送数据，即所谓的全双工。
	而现在使用最广泛的HTTP1.1，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工
	也就是全双工被HTTP1.1用成了半双工
	若是网页文本式场景，可以做到客户端发起请求再由服务器响应，但是网页游戏需要客户端和服务器互相主动发大量数据的场景就不再适用了，所以 一个基于TCP的新协议webSocket诞生

    webSocket连接：
	为了兼容场景，浏览器在TCP三次握手建立连接之后，都统一使用HTTP协议先进行一次通信
	然后1）若是普通HTTP请求，后续双方就还是老样子继续用普通HTTP协议进行交互；2）若是想建立websocket协议，就会在HTTP请求里带上一些特殊的header头，而服务器正好支持升级成WebSocket协议就会走WebSocket握手流程，然后在HTTP响应头部还会带上101状态码，表示协议切换。

26.TCP与UDP的区别
	1）连接：TCP是面向连接的传输层协议，传输数据前先要建立连接；UDP是不需要连接，即刻传输数据
	2）服务对象：TCP是一对一的两点服务，即一条连接只有两个端点；UDP支持一对一、一对多、多对多的交互通信
	3）可靠性：TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达；UDP是尽最大努力交付，不保证可靠交付数据，但是我们可以基于UDP实现一个可靠的传输协议，比如QUIC协议。
	4)拥塞控制、流量控制：TCP有拥塞控制和流量控制，保证数据传输的安全性；UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率
	5）首部开销：TCP首部长度较长，有一定的开销，首部在没有使用【选项】字段时是20个字节，如果使用了【选项】字段则会变长的；UDP首部只有8个字节，并且是固定不变的，开销较小
	6）传输方式：TCP是流式传输，没有编接，但保证顺序和可靠；UDP是一个包一个包的发送，是有边界的，但可能丢包和乱序
	7）分片不同：TCP的数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片； UDP的大小数据如果大于MTU大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，再接着传给传输层。

	一个网络包=报头/起始帧分解符+MAC头部+IP头部+TCP头部+数据+FCS

	注：MTU：一个网络包的最大长度，以太网中一般为1500字节【IP头部+TCP头部+TCP数据】
	    MSS:除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度【TCP数据】
	   

27.TCP与UDP是否可以共用一个端口号？  可以。

28.TCP连接过程（三次握手过程）？
	一开始，客户端和服务端都处于close状态。先是服务端主动监听某个端口，处于listen状态
	三次握手的第一个报文SYN报文：客户端会随机初始化序列号（client_isn）,将此序列号置于TCP首部的【序号】字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态
	三次握手的第二个报文：SYN+ACK 报文：服务端收到客户端的SYN报文后，首先服务端也随机初始化自己的序号（serve_isn）,将此序号填入TCP首部的【序号】字段当中，其次把TCP首部的【确认应答号】字段填入client_isn+1,接着把SYN和ACK标志位置为1.最后把该报文发给客户端，该报文也不含应用层数据，之后服务端处于SYN-RCVD状态
	三次握手的第三个报文：ACK报文：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部ACK标志位置为1，其次【确认应答号】字段填入server_isn+1,最后把报文发送给服务端，这次报文可以携带客户端的数据到服务端，之后客户端处于established状态。服务端收到客户端的应答报文后，也进入established状态。


从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的！！！！

29.为什么是三次握手？

	1）避免历史重连（主要原因）：为了防止旧的重复连接初始化造成混乱。
		=》两次握手连接，就无法阻止历史连接，因为服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费
	2）同步双方初始序列号：TCP协议的通信双方，都必须维护一个【序列号】，序列号是可靠传输的一个关键因素。
	3）避免资源浪费

30.TCP中两方维护的序列号的作用：
	1）接收方可以去除重复的数据。
	2）接收方可以根据数据包的序列号按序接收
	3)可以标识发送出去的数据包中，哪些是已经被对方收到的（通过ACK报文中的序列号知道）

31.为什么每次建立TCP连接时，初始化的序列号都要求不一样呢？
    主要原因如下：
	1）为了防止历史报文被下一个相同四元组的连接接收（主要）；
	2）为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收
    注：如果每次建立连接，客户端和服务端的初始序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收。

32.初始序列号ISN是如何随机产生的？	 
	ISN = M+F,(M是一个计时器，每隔4微妙+1;F是hash算法，根据源IP，目的IP，源端口，目的端口随机生成一个随机数值)

33.既然IP层会分片，那为什么TCP层还需要MSS呢？
	如果在TCP层有一个超过mtu 大小的数据要发送，那么IP层就要进行分片，把数据分片成若干片，保证每一个分片都小于MTU.把一份IP数据报进行分片以后，由目标主机的IP层来进行重新组装后，再交给上一层TCP传输层。
	如果一个IP分片丢失，整个IP报文的所有分片都得重传。因为IP层本身没有超时重传机制，它由传输层的TCP来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。
	所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。
	经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率
	
	一个网络包=报头/起始帧分解符+MAC头部+IP头部+TCP头部+数据+FCS

	注：MTU：一个网络包的最大长度，以太网中一般为1500字节【IP头部+TCP头部+TCP数据】
	    MSS:除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度【TCP数据】

34.第一次握手、第二次握手、第三次握手丢失了分别会发生什么？
	详情：略。大概都是根据内核参数（SYN报文看tcp_syn_retries、SYN+ACK报文看：tcp_synack_retries）最大重新上传的次数=n,分别经过【为上一次时间的两倍】秒进行重传，到最大重传次数后TCP连接自动断开

35.TCP连接断开
	TCP断开连接是四次挥手方式（但是特定情况是可以三次挥手的，请详细看下一点）。双方都可以主动断开连接，断开连接后主机中的资源将被释放。

	1）客户端打算关闭连接，此时会发送一个TCP首部FIN标志位被置为1的报文【FIN报文】，之后客户端进入FIN_WAIT_1状态。
	2）服务端收到该报文后，就向客户端发送ACK应答报文，接着服务端进入CLOSE_WAIT状态。
	3）客户端收到服务端的ACK应答报文后，之后进入FIN_WAIT_2状态
	4)等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态。
	5）客户端收到服务端的FIN报文后，回应一个ACK报文，之后进入TIME_WAIT状态
	6）服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。
	7）客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。
	
36.第一、二、三、四次挥手丢失各会发生什么？
	详情略。

37.为什么需要TIME_WAIT状态？









